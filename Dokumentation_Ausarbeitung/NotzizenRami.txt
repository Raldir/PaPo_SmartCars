Spawnedges wurden statisch gewählt, jene, von denen nur 1 Straße abgeht. Später möglicherweise dynamischer, durch berechnung der Edges mit
minimaler Anzahl an Straßen und diese als Referenz nehmen mit Threshhold

Die Auswahl des Zielknoten eines autos wird in der theorie so angenommen ,dass ein Auto ein Ziel hat (welches bei uns durch eine Wahrscheinlichkeitsfunktion
beschrieben wird) und von dort aus die nächsten n SpawnKnoten wählt um die Route wieder zu verlasen und berechnet, welcher der Spawnpunkte die niedrigste
Kosten hat.
In der Praxis wählen wir einen Knoten mit eiiner bestimmen Wahrscheinlichkeitsfunktion. Von dem wählen wir die nächsten n nachbarn. Macht für die Praxis
keinen unterschied da man i nder Praxis auch einen Knoten aus dem Radius wählen müsste und von dortm öglichst nahe Knoten zum kostenvergleich suchen würde.

Die CostMatrix ist ausschließlich dafür da, die initialkosten zu berechnen, ist also nichts weiteres als die Distanzen zwischen beginn und Ziel


VERBESSERUNGEN

STATT CIRCLEBEZIEHUNG VERTEX EDGE; KANN MAN bsp MAP IM VERTEX ERSTELLEN, mit EDGE ID UND ZIELVERTEX ID

FÜGE ECEPTIONS HINZU FÜR METHODEN DIE WAS RETURNEN WAS FEHLSCHLAGEN KANN!

VERBINDE irgendwie spawner mit den vertecies besser, momentan sind das autonome objekte.

Vielleicht sollte, ein Pointer verwendet werden um die Edges von Vertex zu Spawner zu kopieren.


Das Übergeben des Autos an den Vertex sollte beim paralllelen durchlaufen nicht über ne referenz geschehen, bzw, wenn prozess wechselt,
 muss richtiges objekt übergebenw erden

Float Rundungserror problematisch späteR??!?!?!? bei addDistanceTraveled ist rundunfsfehler

Adde eine Config file, also xml, und die main.h ließt dann die Werte aus der config file aus.

Nutzung von Librarys im Python script::

networkx (muss man explizit einbinden)


Füge hinzu das beim Exportieren die Größe der straße mit in betracht gezogen wird bei der Berechnung der relevanz be iden Spawner(realisterisches Verhalten)


Karte export momentan noch ein wenig buggy.... geht besser, irgendwie muss man unnötige Knoten entfernen könnenn etc. viel arbeit, später

mathplotlib (nicht in pip eingebunden, geht auch ohne muss aber vielel ibs installieren! mit pip)
open cv (muss man explizit einbinden)
numpy

Bei der generierung der Karte kann man noch verbessern, dass unnötige Knoten rausgeworfen werden. Wichtig hierbei ist dass man entweder filtert welche Knoten
Knoten zu fußgängerwegen sind, und anhand dessen diese Knoten löscht und überbrückungskanten erzeugt, oder Man könnte auch einen Smoothing algorithmus schreiben,
der die um Faktor fest reduziert.
Ändert nichts an der Auswertung, da bei der Auswertung nur die Anzahl der Knoten und Kanten als Referenz gewählt wird, nicht die Größe der exportierten Karte.